# 3.2 go 关键字

在 Go 语言中，表达式 go f(x, y, z)会启动一个新的 goroutine 运行函数 f(x, y, z)。函数 f，变量 x、y、z 
的值是在原 goroutine 计算的，只有函数 f 的执行是在新的 goroutine 中的。显然，新的 goroutine 不能和当
前 go 线程用同一个栈，否则会相互覆盖。所以对 go 关键字的调用协议与普通函数调用是不同的。

首先，让我们看一下如果是 C 代码新建一条线程的实现会是什么样子的。大概会先建一个结构体，结构体里存 
f、x、y 和 z 的值。然后写一个 help 函数，将这个结构体指针作为输入，函数体内调用 f(x, y, z)。接下来，
先填充结构体，然后调用 `newThread(help, structptr)`。其中 help 是刚刚那个函数，它会调用 f(x, y, z)。
help 函数将作为所有新建线程的入口函数。

这样做有什么问题么？没什么问题...只是这样实现代价有点高，每次调用都会花上不少的指令。其实 Go 语言中
对 go 关键字的实现会更加 hack 一些，避免了这么做。

先看看正常的函数调用，下面是调用 `f(1, 2, 3)` 时的汇编代码：

```asm
	MOVL    $1, 0(SP)
	MOVL    $2, 4(SP)
	MOVL    $3, 8(SP)
	CALL    f(SB)
```

首先将参数 1、2、3 进栈，然后调用函数f。

下面是 `go f(1, 2, 3)` 生成的代码：

```asm
	MOVL    $1, 0(SP)
	MOVL    $2, 4(SP)
	MOVL    $3, 8(SP)
	PUSHQ   $f(SB)
	PUSHQ   $12
	CALL    runtime.newproc(SB)
	POPQ    AX
	POPQ    AX
```

对比一个会发现，前面部分跟普通函数调用是一样的，将参数存储在正常的位置，并没有新建一个辅助的结构体。
接下来的两条指令有些不同，将 f 和 12 作为参数进栈而不直接调用 f，然后调用函数 `runtime.newproc`。

12 是参数占用的大小。`runtime.newproc` 函数接受的参数分别是：参数大小，新的 goroutine 是要运行的函
数，函数的 n 个参数。

在 `runtime.newproc` 中，会新建一个栈空间，将栈参数的 12 个字节拷贝到新栈空间中并让栈指针指向参数。
这时的线程状态有点像当被调度器剥夺 CPU 后一样，寄存器 PC、SP 会被保存到类似于进程控制块的一个结构体 
struct G 内。f 被存放在了 struct G 的 entry 字段，后面进行调度器恢复 goroutine 的运行，新线程将从 f 
开始执行。

和前面说的如果用 C 实现的差别就在于，没有使用辅助的结构体，而 `runtime.newproc` 实际上就是 help 函
数。在函数协议上，go 表达式调用就比普通的函数调用多四条指令而已，并且在实际上并没有为 go 关键字设计
一套特殊的东西。不得不说这个做法真的非常精妙！

总结一个，go 关键字的实现仅仅是一个语法糖衣而已，也就是：
```go
	go f(args)
```
可以看作

```c
	runtime.newproc(size, f, args)
```

## links
   * [目录](<preface.md>)
   * 上一节: [多值返回](<03.2.md>)
   * 下一节: [defer关键字](<03.4.md>)
